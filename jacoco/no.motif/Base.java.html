<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Base.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Motif</a> &gt; <a href="index.source.html" class="el_package">no.motif</a> &gt; <span class="el_source">Base.java</span></div><h1>Base.java</h1><pre class="source lang-java linenums">package no.motif;

import static no.motif.Iterate.on;

import java.util.Collection;
import java.util.Objects;

import no.motif.f.Do;
import no.motif.f.Fn;
import no.motif.f.Fn0;
import no.motif.f.Fn2;
import no.motif.f.Predicate;
import no.motif.f.Predicate.Always;
import no.motif.f.combine.Conjunction;
import no.motif.f.combine.ConjunctionPremise;
import no.motif.f.combine.Disjunction;
import no.motif.f.combine.DisjunctionPremise;
import no.motif.f.combine.DoChain;
import no.motif.f.combine.Fn2Chain;
import no.motif.f.combine.FnChain;
import no.motif.f.combine.RunnableChain;
import no.motif.f.combine.When;
import no.motif.f.combine.Where;
import no.motif.f.impl.Constant;
import no.motif.f.impl.Throw;
import no.motif.iter.ExtractingIterable;
import no.motif.types.Elements;

/**
 * Basic functions.
 *
 * @see Predicate
 * @see Fn
 */
public final class Base {

    /**
     * Shorthand for {@link #not(Predicate) not(}{@link #equalTo(Object) equalTo(o))}.
     *
     * @see #not(Predicate)
     * @see #equalTo(Object)
     */
<span class="fc" id="L43">    public static &lt;T&gt; Predicate&lt;T&gt; not(T o) { return not(equalTo(o)); }</span>


    /**
     * Negates a predicate.
     * @param p The predicate to negate.
     * @return The new predicate.
     */
    public static &lt;T&gt; Predicate&lt;T&gt; not(final Predicate&lt;T&gt; p) {
<span class="fc bfc" id="L52" title="All 2 branches covered.">        return new Predicate&lt;T&gt;() { @Override public boolean $(T value) { return !p.$(value); }}; }</span>


    /**
     * Compose a predicate from taking the result of a function and apply it to
     * another predicate.
     *
     * &lt;pre&gt;
     * fn(T) &amp;isin; P
     * p(P) &amp;isin; {true, false}
     * &lt;b&gt;&amp;fnof;(T) = p(fn(T)) &amp;isin; {true, false}&lt;/b&gt;
     * &lt;/pre&gt;
     *
     * &lt;p&gt;
     * This simple composition enables one to focus on writing {@link Fn functions}
     * for your particular domain, and reusing basic predicates provided by &lt;em&gt;Motif&lt;/em&gt;.
     * &lt;/p&gt;
     *
     * @param &lt;P&gt;       The type of the predicate evaluating the function result.
     * @param &lt;T&gt;       The type of the resulting predicate.
     * @param fn        The function which result will be evaluated by the predicate. Takes
     *                  an argument of &lt;code&gt;T&lt;/code&gt;
     * @param predicate Evaluates the result from the function, i.e. a value of &lt;code&gt;P&lt;/code&gt;
     * @return          A predicate of &lt;code&gt;T&lt;/code&gt;
     */
    public static &lt;T, P&gt; Predicate&lt;T&gt; where(final Fn&lt;T, P&gt; fn, final Predicate&lt;? super P&gt; predicate) {
<span class="fc" id="L78">        return new Where&lt;T, P&gt;(fn, predicate); }</span>



    /**
     * Create a AND-expression of several predicates, starting with the one
     * given to this method.
     *
     * @see Conjunction
     * @see #allOf(Predicate...)
     * @param predicate The first predicate.
     * @return a new predicate which may be used to build up an AND-expression by
     *         chaining the {@link Conjunction#and(Predicate) and(anotherPredicate)} method.
     */
    public static &lt;T&gt; Conjunction&lt;T&gt; both(Predicate&lt;T&gt; predicate) {
<span class="fc" id="L93">        return new Conjunction&lt;T&gt;(predicate);</span>
    }


    /**
     * Create a AND-expression of several {@link Fn0 Fn0&amp;lt;Boolean&amp;gt;s}, starting with the one
     * given to this method.
     *
     * @see ConjunctionPremise
     * @param premise The first &lt;code&gt;Fn0&amp;lt;Boolean&amp;gt;&lt;/code&gt;.
     * @return a new &lt;code&gt;Fn0&amp;lt;Boolean&amp;gt;&lt;/code&gt; which may be used to build up an AND-expression by
     *         chaining the {@link ConjunctionPremise#and(Fn0) and(anotherPremise)} method.
     */
    public static ConjunctionPremise both(Fn0&lt;Boolean&gt; premise) {
<span class="fc" id="L107">        return new ConjunctionPremise(premise);</span>
    }



    /**
     * Compose an AND-expression of several predicates.
     *
     * @see Conjunction
     * @param predicates the predicates.
     * @return a new predicate which is the conjunction (AND) of the given predicates.
     */
    @SafeVarargs
    @SuppressWarnings(&quot;varargs&quot;)
    public static &lt;T&gt; Conjunction&lt;T&gt; allOf(Predicate&lt;? super T&gt; ... predicates) {
<span class="fc" id="L122">        return new Conjunction&lt;&gt;(predicates);</span>
    }

    /**
     * Compose an AND-expression of several {@link Fn0 Fn0&amp;lt;Boolean&amp;gt;s}.
     *
     * @see ConjunctionPremise
     * @param premises the &lt;code&gt;Fn0&amp;lt;Boolean&amp;gt;s&lt;/code&gt;.
     * @return a new &lt;code&gt;Fn0&amp;lt;Boolean&amp;gt;&lt;/code&gt; which is the conjunction
     *         (AND) of the given premises.
     */
    @SafeVarargs
    @SuppressWarnings(&quot;varargs&quot;)
    public static ConjunctionPremise allOf(Fn0&lt;Boolean&gt; ... premises) {
<span class="fc" id="L136">        return new ConjunctionPremise(premises);</span>
    }



    /**
     * Shorthand for {@link #either(Predicate) either(}{@link #equalTo(Object) equalTo(o))}.
     *
     * @see #either(Predicate)
     * @see Disjunction
     */
<span class="fc" id="L147">    public static &lt;T&gt; Disjunction&lt;T&gt; either(T o) { return either(equalTo(o)); }</span>

    /**
     * Create a OR-expression of several predicates, starting with the one
     * given to this method.
     *
     * @see Disjunction
     * @see #anyOf(Predicate...)
     * @param predicate The first predicate.
     * @return a new predicate which may be used to build up an OR-expression by
     *         chaining the {@link Disjunction#or(Predicate) or(anotherPredicate)} method.
     */
    public static &lt;T&gt; Disjunction&lt;T&gt; either(Predicate&lt;T&gt; predicate) {
<span class="fc" id="L160">        return new Disjunction&lt;T&gt;(predicate);</span>
    }


    /**
     * Create a OR-expression of several {@link Fn0 Fn0&amp;lt;Boolean&amp;gt;s},
     * starting with the one given to this method.
     *
     * @see DisjunctionPremise
     * @param premise The first &lt;code&gt;Fn0&amp;lt;Boolean&amp;gt;&lt;/code&gt;.
     * @return a new &lt;code&gt;Fn0&amp;lt;Boolean&amp;gt;&lt;/code&gt; which may be used to build up an OR-expression by
     *         chaining the {@link DisjunctionPremise#or(Fn0) or(anotherPremise)} method.
     */
    public static DisjunctionPremise either(Fn0&lt;Boolean&gt; premise) {
<span class="fc" id="L174">        return new DisjunctionPremise(premise);</span>
    }


    /**
     * Shorthand for
     * {@link #anyOf(Predicate...) anyOf(}{@link #equalTo(Object) equalTo(o1), equalTo(o2), ..., equalTo(on))}
     *
     * @param objects the candidate objects for equivalence check.
     * @see Disjunction
     */
    @SafeVarargs
    @SuppressWarnings(&quot;varargs&quot;)
    public static &lt;T&gt; Disjunction&lt;T&gt; anyOf(T ... objects) {
        @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L189">        Predicate&lt;T&gt;[] equalToPredicates = on(objects)</span>
<span class="fc" id="L190">            .map(new Fn&lt;T, Predicate&lt;T&gt;&gt;() { @Override public Predicate&lt;T&gt; $(T o) { return equalTo(o); }})</span>
<span class="fc" id="L191">            .collect().toArray(new Predicate[objects.length]);</span>
<span class="fc" id="L192">        return anyOf(equalToPredicates);</span>
    }


    /**
     * Compose an OR-expression of several predicates.
     *
     * @see Disjunction
     * @param predicates the predicates.
     * @return a new predicate which is the disjunction (OR) of the given predicates.
     */
    @SafeVarargs
    @SuppressWarnings(&quot;varargs&quot;)
    public static &lt;T&gt; Disjunction&lt;T&gt; anyOf(Predicate&lt;? super T&gt; ... predicates) {
<span class="fc" id="L206">        return new Disjunction&lt;&gt;(predicates);</span>
    }


    /**
     * Compose an OR-expression of several {@link Fn0 Fn0&amp;lt;Boolean&amp;gt;s}.
     *
     * @see DisjunctionPremise
     * @param premises the &lt;code&gt;Fn0&amp;lt;Boolean&amp;gt;s&lt;/code&gt;.
     * @return a new &lt;code&gt;Fn0&amp;lt;Boolean&amp;gt;s&lt;/code&gt; which is the disjunction (OR) of the given premises.
     */
    @SafeVarargs
    @SuppressWarnings(&quot;varargs&quot;)
    public static DisjunctionPremise anyOf(Fn0&lt;Boolean&gt; ... premises) {
<span class="fc" id="L220">        return new DisjunctionPremise(premises);</span>
    }


    /**
     * Evaluate if all elements satisfies a predicate, i.e. the &lt;em&gt;Universal quantifier function&lt;/em&gt;.
     * Note that the predicate
     *
     * @param predicate The predicate which will evaluate all elements.
     * @return a predicate which evaluates to &lt;code&gt;true&lt;/code&gt; if all elements evaluates
     *         to true by the given predicate, false if any evaluates to &lt;code&gt;false&lt;/code&gt;.
     */
    public static &lt;E, I extends Iterable&lt;E&gt;&gt; Predicate&lt;I&gt; all(final Predicate&lt;? super E&gt; predicate) {
<span class="fc" id="L233">        return new Predicate&lt;I&gt;() { @Override public boolean $(I iterable) {</span>
<span class="fc" id="L234">            return on(iterable).filter(not(predicate)).isEmpty(); }};}</span>


    /**
     * Shorthand for {@link #exists(Predicate) exists(}{@link #equalTo(Object) equalTo(element))}
     *
     * @param element The element to look for in an {@link Iterable}.
     * @return a predicate which evaluates to &lt;code&gt;true&lt;/code&gt; if an element equal to the given
     *         element is found, &lt;code&gt;false&lt;/code&gt; otherwise.
     */
<span class="fc" id="L244">    public static &lt;E, I extends Iterable&lt;E&gt;&gt; Predicate&lt;I&gt; exists(E element) { return exists(equalTo(element)); }</span>


    /**
     * Evaluate if an element exists, i.e. the &lt;em&gt;Existential quantifier function&lt;/em&gt;.
     *
     * @param element The existance-deciding predicate.
     * @return a predicate which evaluates to &lt;code&gt;true&lt;/code&gt; if any element evaluates
     *         to true by the given predicate, &lt;code&gt;false&lt;/code&gt; otherwise.
     */
    public static &lt;E, I extends Iterable&lt;E&gt;&gt; Predicate&lt;I&gt; exists(final Predicate&lt;? super E&gt; element) {
<span class="fc" id="L255">        return new Predicate&lt;I&gt;() { @Override public boolean $(I iterable) {</span>
<span class="fc" id="L256">            return on(iterable).exists(element); }};}</span>


    /**
     * A synonym for {@link #equalTo(Object)}.
     */
<span class="fc" id="L262">    public static &lt;T&gt; Predicate&lt;T&gt; is(T value) { return equalTo(value); }</span>


    /**
     * Equality predicate, checks if values are equal to the given value.
     *
     * @param value the value the predicate should check for equality against.
     */
<span class="fc" id="L270">    public static &lt;T&gt; Predicate&lt;T&gt; equalTo(final T value) { return equalTo(always(value)); }</span>


    /**
     * Equality predicate, checks if values are equal to the value computed from the given {@link Fn0}.
     *
     * @param value the {@link Fn0} which will compute the value to check for equality against on each
     *              application of the predicate.
     */
    public static &lt;T&gt; Predicate&lt;T&gt; equalTo(final Fn0&lt;? super T&gt; value) {
<span class="fc" id="L280">        return new Predicate&lt;T&gt;() { @Override public boolean $(T input) {</span>
<span class="fc" id="L281">            return Objects.equals(input, value.$()); }}; }</span>


    /**
     * Predicate evaluating if values are less than a given value.
     *
     * @param value the right operand, i.e. the predicate will evaluate
     *              if values are less than this value.
     * @return the &quot;&lt;em&gt;&amp;lt; value&lt;/em&gt;&quot; predicate
     */
    public static &lt;T extends Comparable&lt;? super T&gt;&gt; Predicate&lt;T&gt; lessThan(final T value) {
<span class="fc bfc" id="L292" title="All 2 branches covered.">        return new Predicate&lt;T&gt;() { @Override public boolean $(T candidate) { return candidate.compareTo(value) &lt; 0; }}; }</span>


    /**
     * Predicate evaluating if values are equal to or less than a given value.
     *
     * @param value the right operand, i.e. the predicate will evaluate
     *              if values are equal to or less than this value.
     * @return the &quot;&lt;em&gt;=&amp;lt; value&lt;/em&gt;&quot; predicate
     */
    public static &lt;T extends Comparable&lt;? super T&gt;&gt; Predicate&lt;T&gt; equalOrLessThan(T value) {
<span class="fc" id="L303">        return either(equalTo(value)).or(lessThan(value)); }</span>



    /**
     * Predicate evaluating if values are greater than a given value.
     *
     * @param value the right operand, i.e. the predicate will evaluate
     *              if values are greater than this value.
     * @return the &quot;&lt;em&gt;&amp;gt; value&lt;/em&gt;&quot; predicate
     */
    public static &lt;T extends Comparable&lt;? super T&gt;&gt; Predicate&lt;T&gt; greaterThan(final T value) {
<span class="fc bfc" id="L315" title="All 2 branches covered.">        return new Predicate&lt;T&gt;() { @Override public boolean $(T candidate) { return candidate.compareTo(value) &gt; 0; }}; }</span>


    /**
     * Predicate evaluating if values are equal to or greater than a given value.
     *
     * @param value the right operand, i.e. the predicate will evaluate
     *              if values are equal to or greater than this value.
     * @return the &quot;&lt;em&gt;&amp;gt;= value&lt;/em&gt;&quot; predicate
     */
    public static &lt;T extends Comparable&lt;? super T&gt;&gt; Predicate&lt;T&gt; equalOrGreaterThan(T value) {
<span class="fc" id="L326">        return either(equalTo(value)).or(greaterThan(value)); }</span>



    /**
     * Yields &lt;code&gt;true&lt;/code&gt; for &lt;code&gt;null&lt;/code&gt; values.
     */
<span class="fc" id="L333">    public static final Predicate&lt;Object&gt; isNull = new Predicate&lt;Object&gt;() {</span>
<span class="fc bfc" id="L334" title="All 2 branches covered.">        @Override public boolean $(Object value) { return value == null; }};</span>


    /**
     * Yields &lt;code&gt;true&lt;/code&gt; for all non-&lt;code&gt;null&lt;/code&gt; values.
     */
<span class="fc" id="L340">    public static final Predicate&lt;Object&gt; notNull = not(isNull);</span>



    /**
     * A function to extract/derive several values from one object. The result of the
     * extraction is an {@link Elements}s container of the least common supertype of
     * the extractor {@link Fn}s' return types.
     *
     * @param extractors the {@link Fn}s which will extract values from each object passed
     *        to the function.
     *
     * @return the composed function which yields.
     */
    @SafeVarargs
    public static &lt;T, E&gt; Fn&lt;T, Elements&lt;E&gt;&gt; extract(final Fn&lt;? super T, ? extends E&gt; ... extractors) {
<span class="fc" id="L356">        return new Fn&lt;T, Elements&lt;E&gt;&gt;() { @Override public Elements&lt;E&gt; $(T value) {</span>
<span class="fc" id="L357">                return on(new ExtractingIterable&lt;T, E&gt;(value, on(extractors))); }}; }</span>


    /**
     * Yields the {@link String#valueOf(Object) string representation} of
     * any object.
     */
<span class="fc" id="L364">    public static final Fn&lt;Object, String&gt; toString = new Fn&lt;Object, String&gt;() {</span>
<span class="fc" id="L365">        @Override public String $(Object value) { return String.valueOf(value); }};</span>


    /**
     * Yields the {@link Object#hashCode() hashCode} for objects, or 0 if &lt;code&gt;null&lt;/code&gt;.
     */
<span class="fc" id="L371">    public static final Fn&lt;Object, Integer&gt; hashCode = new Fn&lt;Object, Integer&gt;() {</span>
<span class="fc bfc" id="L372" title="All 2 branches covered.">        @Override public Integer $(Object o) { return o != null ? o.hashCode() : 0; }};</span>


    /**
     * Creates a &quot;guarded&quot; {@link Fn} using a {@link Predicate} to evaluate if the
     * argument should be passed to the wrapped &lt;code&gt;Fn&lt;/code&gt;. The function created
     * by this method is essentially this ternary expression:
     * &lt;pre&gt; condition(v) ? f(v) : null;&lt;/pre&gt;
     * To fall back to another value than &lt;code&gt;null&lt;/code&gt;, call either {@link When#orElse(Fn) .orElse(Fn)}
     * or {@link When#orElse(Object) .orElse(other)} on the returned object.
     *
     * @param condition Only when this evaluates to &lt;code&gt;true&lt;/code&gt; will the function argument
     *                  be applied to the given {@link Fn}.
     * @param fn        The {@link Fn} to apply if &lt;code&gt;condition&lt;/code&gt; evaluates to &lt;code&gt;true&lt;/code&gt;
     */
    public static &lt;I, O&gt; When&lt;I, O&gt; when(Predicate&lt;? super I&gt; condition, Fn&lt;? super I, ? extends O&gt; fn) {
<span class="fc" id="L388">        return new When&lt;&gt;(condition, fn);</span>
    }


    /**
     * Compose a chain of several functions into one {@link Fn}, where the result of
     * each function is passed to its successor, and the last will yield the
     * actual result of the chain. Use {@link FnChain#then(Fn) .then(Fn)} to append
     * functions to the chain.
     *
     * &lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; The chain does no internal inspection of the intermediate
     * results passed to the next function, which means that any function which may
     * return &lt;code&gt;null&lt;/code&gt;, &lt;em&gt;must&lt;/em&gt; have a &lt;code&gt;null&lt;/code&gt;-safe successor
     * function.
     *
     * @param fn The first function in the chain.
     * @return the given function as the first function in a chain.
     */
    public static final &lt;I, O&gt; FnChain&lt;I, O&gt; first(Fn&lt;I, O&gt; fn) {
<span class="fc" id="L407">        return FnChain.chain(fn);</span>
    }


    /**
     * Compose a chain of several functions into one {@link Fn2}, where the result of
     * each function is passed to its successor, and the last will yield the
     * actual result of the chain. Use {@link Fn2Chain#then(Fn) .then(Fn)} to append
     * functions to the chain.
     *
     * &lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; The chain does no inspection of the intermediate
     * results passed to the next function, which means that any function which may
     * return &lt;code&gt;null&lt;/code&gt;, &lt;em&gt;must&lt;/em&gt; have a &lt;code&gt;null&lt;/code&gt;-safe successor
     * function.
     *
     * @param fn2 The first function in the chain.
     * @return the given function as the first function in a chain.
     */
    public static final &lt;I1, I2, O&gt; Fn2Chain&lt;I1, I2, O, O&gt; first(Fn2&lt;I1, I2, O&gt; fn2) {
<span class="fc" id="L426">        return new Fn2Chain&lt;&gt;(fn2, NOP.&lt;O&gt;fn());</span>
    }


    /**
     * Compose several {@link Runnable}s as a single Runnable which will
     * execute the given Runnables in sequence.
     *
     * @param runnable The first Runnable.
     * @return the given Runnable as the first Runnable in a sequence.
     */
    public static final RunnableChain first(Runnable runnable) {
<span class="fc" id="L438">        return new RunnableChain(runnable, NOP.runnable);</span>
    }


    /**
     * Chain several {@link Do}s to be executed in sequence.
     *
     * @param action The first {@link Do} to execute.
     * @return The given &lt;code&gt;Do&lt;/code&gt; as the first &lt;code&gt;Do&lt;/code&gt; in a sequence.
     */
    public static &lt;V&gt; DoChain&lt;V&gt; first(Do&lt;V&gt; action) {
<span class="fc" id="L449">        return new DoChain&lt;&gt;(action, NOP.doNothing);</span>
    }


    /**
     * Create a function which always yields the given value.
     *
     * @param value The value to yield.
     */
<span class="fc" id="L458">    public static &lt;I1, I2, V&gt; Constant&lt;I1, I2, V&gt; always(V value) { return new Constant&lt;&gt;(value); }</span>


    /**
     * Create a predicate which always yields the given &lt;code&gt;boolean&lt;/code&gt; value.
     *
     * @param bool The &lt;code&gt;boolean&lt;/code&gt; value to yield.
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;T&gt; Predicate&lt;T&gt; always(boolean bool) {
<span class="fc bfc" id="L468" title="All 2 branches covered.">        return (Predicate&lt;T&gt;) (bool ? Predicate.Always.yes() : Predicate.Always.no());</span>
    }



    /**
     * Create a function which always throw the given exception. If the
     * exception is not a {@link RuntimeException} it will be wrapped as such.
     *
     * @param ex The exception to throw.
     */
<span class="fc" id="L479">    public static &lt;I1, I2, O&gt; Throw&lt;I1, I2, O&gt; alwaysThrow(Exception ex) { return new Throw&lt;&gt;(ex); }</span>



    /**
     * Evaluates if objects are contained in the given &lt;code&gt;Iterable&lt;/code&gt;.
     */
    public static &lt;T&gt; Predicate&lt;T&gt; containedIn(final Iterable&lt;? extends T&gt; iterable) {
<span class="fc bfc" id="L487" title="All 2 branches covered.">        if (iterable == null) return Always.&lt;T&gt;no();</span>
<span class="fc bfc" id="L488" title="All 2 branches covered.">        if (iterable instanceof Collection) {</span>
<span class="fc" id="L489">            final Collection&lt;? extends T&gt; collection = (Collection&lt;? extends T&gt;) iterable;</span>
<span class="fc bfc" id="L490" title="All 2 branches covered.">            return collection.isEmpty() ? Always.&lt;T&gt;no() : new Predicate&lt;T&gt;() {</span>
<span class="fc" id="L491">                @Override public boolean $(T value) { return collection.contains(value); }};</span>
        } else {
<span class="fc" id="L493">            final Elements&lt;? extends T&gt; elements = on(iterable);</span>
<span class="fc" id="L494">            return new Predicate&lt;T&gt;() {</span>
<span class="fc" id="L495">                @Override public boolean $(T value) { return elements.exists(is(value)); }};</span>
        }

    }

<span class="fc" id="L500">    private Base() {}</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.6.201602180812</span></div></body></html>