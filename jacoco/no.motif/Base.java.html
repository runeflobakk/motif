<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Base.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Motif</a> &gt; <a href="index.source.html" class="el_package">no.motif</a> &gt; <span class="el_source">Base.java</span></div><h1>Base.java</h1><pre class="source lang-java linenums">package no.motif;

import static no.motif.Iterate.on;

import java.util.Objects;

import no.motif.f.Do;
import no.motif.f.Fn;
import no.motif.f.Fn2;
import no.motif.f.Predicate;
import no.motif.f.combine.Conjunction;
import no.motif.f.combine.Disjunction;
import no.motif.f.combine.DoChain;
import no.motif.f.combine.Fn2Chain;
import no.motif.f.combine.FnChain;
import no.motif.f.combine.RunnableChain;
import no.motif.f.combine.When;
import no.motif.f.combine.Where;
import no.motif.f.impl.Constant;
import no.motif.f.impl.Throw;
import no.motif.iter.ExtractingIterable;
import no.motif.types.Elements;

/**
 * Basic functions.
 *
 * @see Predicate
 * @see Fn
 */
public final class Base {

    /**
     * Negates a predicate.
     * @param p The predicate to negate.
     * @return The new predicate.
     */
    public static &lt;T&gt; Predicate&lt;T&gt; not(final Predicate&lt;T&gt; p) {
<span class="fc bfc" id="L38" title="All 2 branches covered.">        return new Predicate&lt;T&gt;() { @Override public boolean $(T value) { return !p.$(value); }}; }</span>


    /**
     * Compose a predicate from taking the result of a function and apply it to
     * another predicate.
     *
     * &lt;pre&gt;
     * fn(T) &amp;isin; P
     * p(P) &amp;isin; {true, false}
     * &lt;b&gt;&amp;fnof;(T) = p(fn(T)) &amp;isin; {true, false}&lt;/b&gt;
     * &lt;/pre&gt;
     *
     * &lt;p&gt;
     * This simple composition enables one to focus on writing {@link Fn functions}
     * for your particular domain, and reusing basic predicates provided by &lt;em&gt;Motif&lt;/em&gt;.
     * &lt;/p&gt;
     *
     * @param &lt;P&gt;       The type of the predicate evaluating the function result.
     * @param &lt;T&gt;       The type of the resulting predicate.
     * @param fn        The function which result will be evaluated by the predicate. Takes
     *                  an argument of &lt;code&gt;T&lt;/code&gt;
     * @param predicate Evaluates the result from the function, i.e. a value of &lt;code&gt;P&lt;/code&gt;
     * @return          A predicate of &lt;code&gt;T&lt;/code&gt;
     */
    public static &lt;T, P&gt; Predicate&lt;T&gt; where(final Fn&lt;T, P&gt; fn, final Predicate&lt;? super P&gt; predicate) {
<span class="fc" id="L64">        return new Where&lt;T, P&gt;(fn, predicate); }</span>



    /**
     * Create a AND-expression of several predicates, starting with the one
     * given to this method.
     *
     * @see Conjunction
     * @see #allOf(Predicate...)
     * @param predicate The first predicate.
     * @return a new predicate which may be used to build up an AND-expression by
     *         chaining the {@link Conjunction#and(Predicate) and(anotherPredicate)} method.
     */
    public static &lt;T&gt; Conjunction&lt;T&gt; both(Predicate&lt;T&gt; predicate) {
<span class="fc" id="L79">        return new Conjunction&lt;T&gt;(predicate);</span>
    }



    /**
     * Compose an AND-expression of several predicates.
     *
     * @see Conjunction
     * @param predicates the predicates.
     * @return a new predicate which is the conjunction (AND) of the given predicates.
     */
    @SafeVarargs
    @SuppressWarnings(&quot;varargs&quot;)
    public static &lt;T&gt; Conjunction&lt;T&gt; allOf(Predicate&lt;? super T&gt; ... predicates) {
<span class="fc" id="L94">        return new Conjunction&lt;&gt;(predicates);</span>
    }



    /**
     * Create a OR-expression of several predicates, starting with the one
     * given to this method.
     *
     * @see Disjunction
     * @see #anyOf(Predicate...)
     * @param predicate The first predicate.
     * @return a new predicate which may be used to build up an OR-expression by
     *         chaining the {@link Disjunction#or(Predicate) or(anotherPredicate)} method.
     */
    public static &lt;T&gt; Disjunction&lt;T&gt; either(Predicate&lt;T&gt; predicate) {
<span class="fc" id="L110">        return new Disjunction&lt;T&gt;(predicate);</span>
    }



    /**
     * Compose an OR-expression of several predicates.
     *
     * @see Disjunction
     * @param predicates the predicates.
     * @return a new predicate which is the disjunction (OR) of the given predicates.
     */
    @SafeVarargs
    @SuppressWarnings(&quot;varargs&quot;)
    public static &lt;T&gt; Disjunction&lt;T&gt; anyOf(Predicate&lt;? super T&gt; ... predicates) {
<span class="fc" id="L125">        return new Disjunction&lt;&gt;(predicates);</span>
    }


    /**
     * Evaluate if all elements satisfies a predicate, i.e. the &lt;em&gt;Universal quantifier function&lt;/em&gt;.
     * Note that the predicate
     *
     * @param predicate The predicate which will evaluate all elements.
     * @return a predicate which evaluates to &lt;code&gt;true&lt;/code&gt; if all elements evaluates
     *         to true by the given predicate, false if any evaluates to &lt;code&gt;false&lt;/code&gt;.
     */
    public static &lt;E, I extends Iterable&lt;E&gt;&gt; Predicate&lt;I&gt; all(final Predicate&lt;? super E&gt; predicate) {
<span class="fc" id="L138">        return new Predicate&lt;I&gt;() { @Override public boolean $(I iterable) {</span>
<span class="fc" id="L139">            return on(iterable).filter(not(predicate)).isEmpty(); }};}</span>


    /**
     * Evaluate if an element exists, i.e. the &lt;em&gt;Existential quantifier function&lt;/em&gt;.
     *
     * @param element The existance-deciding predicate.
     * @return a predicate which evaluates to &lt;code&gt;true&lt;/code&gt; if any element evaluates
     *         to true by the given predicate, &lt;code&gt;false&lt;/code&gt; otherwise.
     */
    public static &lt;E, I extends Iterable&lt;E&gt;&gt; Predicate&lt;I&gt; exists(final Predicate&lt;? super E&gt; element) {
<span class="fc" id="L150">        return new Predicate&lt;I&gt;() { @Override public boolean $(I iterable) {</span>
<span class="fc" id="L151">            return on(iterable).exists(element); }};}</span>


    /**
     * A synonym for {@link #equalTo(Object)}.
     */
<span class="fc" id="L157">    public static &lt;T&gt; Predicate&lt;T&gt; is(T value) { return equalTo(value); }</span>


    /**
     * Equality predicate, checks if values are equal to the given value.
     *
     * @param value the value the predicate should check for equality against.
     * @return the equality predicate.
     */
    public static &lt;T&gt; Predicate&lt;T&gt; equalTo(final T value) {
<span class="fc" id="L167">        return new Predicate&lt;T&gt;() { @Override public boolean $(T input) { return Objects.equals(input, value); }}; }</span>


    /**
     * Predicate evaluating if values are less than a given value.
     *
     * @param value the right operand, i.e. the predicate will evaluate
     *              if values are less than this value.
     * @return the &quot;&lt;em&gt;&amp;lt; value&lt;/em&gt;&quot; predicate
     */
    public static &lt;T extends Comparable&lt;? super T&gt;&gt; Predicate&lt;T&gt; lessThan(final T value) {
<span class="fc bfc" id="L178" title="All 2 branches covered.">        return new Predicate&lt;T&gt;() { @Override public boolean $(T candidate) { return candidate.compareTo(value) &lt; 0; }}; }</span>


    /**
     * Predicate evaluating if values are equal to or less than a given value.
     *
     * @param value the right operand, i.e. the predicate will evaluate
     *              if values are equal to or less than this value.
     * @return the &quot;&lt;em&gt;=&amp;lt; value&lt;/em&gt;&quot; predicate
     */
    public static &lt;T extends Comparable&lt;? super T&gt;&gt; Predicate&lt;T&gt; equalOrLessThan(T value) {
<span class="fc" id="L189">        return either(equalTo(value)).or(lessThan(value)); }</span>



    /**
     * Predicate evaluating if values are greater than a given value.
     *
     * @param value the right operand, i.e. the predicate will evaluate
     *              if values are greater than this value.
     * @return the &quot;&lt;em&gt;&amp;gt; value&lt;/em&gt;&quot; predicate
     */
    public static &lt;T extends Comparable&lt;? super T&gt;&gt; Predicate&lt;T&gt; greaterThan(final T value) {
<span class="fc bfc" id="L201" title="All 2 branches covered.">        return new Predicate&lt;T&gt;() { @Override public boolean $(T candidate) { return candidate.compareTo(value) &gt; 0; }}; }</span>


    /**
     * Predicate evaluating if values are equal to or greater than a given value.
     *
     * @param value the right operand, i.e. the predicate will evaluate
     *              if values are equal to or greater than this value.
     * @return the &quot;&lt;em&gt;&amp;gt;= value&lt;/em&gt;&quot; predicate
     */
    public static &lt;T extends Comparable&lt;? super T&gt;&gt; Predicate&lt;T&gt; equalOrGreaterThan(T value) {
<span class="fc" id="L212">        return either(equalTo(value)).or(greaterThan(value)); }</span>



    /**
     * Yields &lt;code&gt;true&lt;/code&gt; for &lt;code&gt;null&lt;/code&gt; values.
     */
<span class="fc" id="L219">    public static final Predicate&lt;Object&gt; isNull = new Predicate&lt;Object&gt;() {</span>
<span class="fc bfc" id="L220" title="All 2 branches covered.">        @Override public boolean $(Object value) { return value == null; }};</span>


    /**
     * Yields &lt;code&gt;true&lt;/code&gt; for all non-&lt;code&gt;null&lt;/code&gt; values.
     */
<span class="fc" id="L226">    public static final Predicate&lt;Object&gt; notNull = not(isNull);</span>



    /**
     * A function to extract/derive several values from one object. The result of the
     * extraction is an {@link Elements}s container of the least common supertype of
     * the extractor {@link Fn}s' return types.
     *
     * @param extractors the {@link Fn}s which will extract values from each object passed
     *        to the function.
     *
     * @return the composed function which yields.
     */
    @SafeVarargs
    public static &lt;T, E&gt; Fn&lt;T, Elements&lt;E&gt;&gt; extract(final Fn&lt;? super T, ? extends E&gt; ... extractors) {
<span class="fc" id="L242">        return new Fn&lt;T, Elements&lt;E&gt;&gt;() { @Override public Elements&lt;E&gt; $(T value) {</span>
<span class="fc" id="L243">                return on(new ExtractingIterable&lt;T, E&gt;(value, on(extractors))); }}; }</span>


    /**
     * Yields the {@link String#valueOf(Object) string representation} of
     * any object.
     */
<span class="fc" id="L250">    public static final Fn&lt;Object, String&gt; toString = new Fn&lt;Object, String&gt;() {</span>
<span class="fc" id="L251">        @Override public String $(Object value) { return String.valueOf(value); }};</span>



    /**
     * Get the {@link Throwable#getMessage() message} of a &lt;code&gt;Throwable&lt;/code&gt;.
     */
<span class="fc" id="L258">    public static final Fn&lt;Throwable, String&gt; message = new Fn&lt;Throwable, String&gt;() {</span>
<span class="fc" id="L259">        @Override public String $(Throwable throwable) { return throwable.getMessage(); }};</span>


    /**
     * Get the {@link Throwable#getCause() cause} of a &lt;code&gt;Throwable&lt;/code&gt;.
     */
<span class="fc" id="L265">    public static final Fn&lt;Throwable, Throwable&gt; cause = new Fn&lt;Throwable, Throwable&gt;() {</span>
<span class="fc" id="L266">        @Override public Throwable $(Throwable throwable) { return throwable.getCause(); }};</span>


    /**
     * Creates a &quot;guarded&quot; {@link Fn} using a {@link Predicate} to evaluate if the
     * argument should be passed to the wrapped &lt;code&gt;Fn&lt;/code&gt;. The function created
     * by this method is essentially this ternary expression:
     * &lt;pre&gt; condition(v) ? f(v) : null;&lt;/pre&gt;
     * To fall back to another value than &lt;code&gt;null&lt;/code&gt;, call either {@link When#orElse(Fn) .orElse(Fn)}
     * or {@link When#orElse(Object) .orElse(other)} on the returned object.
     *
     * @param condition Only when this evaluates to &lt;code&gt;true&lt;/code&gt; will the function argument
     *                  be applied to the given {@link Fn}.
     * @param fn        The {@link Fn} to apply if &lt;code&gt;condition&lt;/code&gt; evaluates to &lt;code&gt;true&lt;/code&gt;
     */
    public static &lt;I, O&gt; When&lt;I, O&gt; when(Predicate&lt;? super I&gt; condition, Fn&lt;I, O&gt; fn) {
<span class="fc" id="L282">        return new When&lt;&gt;(condition, fn);</span>
    }


    /**
     * Compose a chain of several functions into one {@link Fn}, where the result of
     * each function is passed to its successor, and the last will yield the
     * actual result of the chain. Use {@link FnChain#then(Fn) .then(Fn)} to append
     * functions to the chain.
     *
     * &lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; The chain does no internal inspection of the intermediate
     * results passed to the next function, which means that any function which may
     * return &lt;code&gt;null&lt;/code&gt;, &lt;em&gt;must&lt;/em&gt; have a &lt;code&gt;null&lt;/code&gt;-safe successor
     * function.
     *
     * @param fn The first function in the chain.
     * @return the given function as the first function in a chain.
     */
    public static final &lt;I, O&gt; FnChain&lt;I, O, O&gt; first(Fn&lt;I, O&gt; fn) {
<span class="fc" id="L301">        return new FnChain&lt;&gt;(fn, NOP.&lt;O&gt;fn());</span>
    }


    /**
     * Compose a chain of several functions into one {@link Fn2}, where the result of
     * each function is passed to its successor, and the last will yield the
     * actual result of the chain. Use {@link Fn2Chain#then(Fn) .then(Fn)} to append
     * functions to the chain.
     *
     * &lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; The chain does no inspection of the intermediate
     * results passed to the next function, which means that any function which may
     * return &lt;code&gt;null&lt;/code&gt;, &lt;em&gt;must&lt;/em&gt; have a &lt;code&gt;null&lt;/code&gt;-safe successor
     * function.
     *
     * @param fn2 The first function in the chain.
     * @return the given function as the first function in a chain.
     */
    public static final &lt;I1, I2, O&gt; Fn2Chain&lt;I1, I2, O, O&gt; first(Fn2&lt;I1, I2, O&gt; fn2) {
<span class="fc" id="L320">        return new Fn2Chain&lt;&gt;(fn2, NOP.&lt;O&gt;fn());</span>
    }


    /**
     * Compose several {@link Runnable}s as a single Runnable which will
     * execute the given Runnables in sequence.
     *
     * @param runnable The first Runnable.
     * @return the given Runnable as the first Runnable in a sequence.
     */
    public static final RunnableChain first(Runnable runnable) {
<span class="fc" id="L332">        return new RunnableChain(runnable, NOP.runnable);</span>
    }


    /**
     * Chain several {@link Do}s to be executed in sequence.
     *
     * @param action The first {@link Do} to execute.
     * @return The given &lt;code&gt;Do&lt;/code&gt; as the first &lt;code&gt;Do&lt;/code&gt; in a sequence.
     */
    public static &lt;V&gt; DoChain&lt;V&gt; first(Do&lt;V&gt; action) {
<span class="fc" id="L343">        return new DoChain&lt;&gt;(action, NOP.doNothing);</span>
    }


    /**
     * Create a function which always yields the given value.
     *
     * @param value The value to yield.
     */
<span class="fc" id="L352">    public static &lt;I1, I2, V&gt; Constant&lt;I1, I2, V&gt; always(V value) { return new Constant&lt;&gt;(value); }</span>



    /**
     * Create a function which always throw the given exception. If the
     * exception is not a {@link RuntimeException} it will be wrapped as such.
     *
     * @param ex The exception to throw.
     */
<span class="fc" id="L362">    public static &lt;I1, I2, O&gt; Throw&lt;I1, I2, O&gt; alwaysThrow(Exception ex) { return new Throw&lt;&gt;(ex); }</span>




<span class="fc" id="L367">    private Base() {}</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.0.201403182114</span></div></body></html>