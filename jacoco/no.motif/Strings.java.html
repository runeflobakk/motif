<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Strings.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Motif</a> &gt; <a href="index.source.html" class="el_package">no.motif</a> &gt; <span class="el_source">Strings.java</span></div><h1>Strings.java</h1><pre class="source lang-java linenums">package no.motif;

import static java.util.Arrays.asList;
import static no.motif.Base.all;
import static no.motif.Base.always;
import static no.motif.Base.alwaysThrow;
import static no.motif.Base.both;
import static no.motif.Base.equalTo;
import static no.motif.Base.exists;
import static no.motif.Base.not;
import static no.motif.Base.where;
import static no.motif.Chars.digit;
import static no.motif.Chars.letter;
import static no.motif.Chars.letterOrDigit;
import static no.motif.Chars.whitespace;
import static no.motif.Exceptions.asRuntimeException;
import static no.motif.Ints.add;
import static no.motif.Iterate.on;
import static no.motif.Singular.optional;
import static no.motif.f.Apply.argsReversed;

import java.io.UnsupportedEncodingException;
import java.util.Collections;

import no.motif.f.Apply;
import no.motif.f.Fn;
import no.motif.f.Fn2;
import no.motif.f.Predicate;
import no.motif.f.Predicate.Always;
import no.motif.f.base.DefaultIfArgIsNull;
import no.motif.f.base.FalseIfNull;
import no.motif.f.base.NullIfArgIsNull;
import no.motif.single.Optional;

/**
 * Functions operating on {@link String strings}.
 */
public final class Strings {

    /**
     * Converts a string to a &lt;code&gt;int&lt;/code&gt; value using {@link Integer#valueOf(String)}.
     * If the string is &lt;code&gt;null&lt;/code&gt;, 0 is yielded.
     */
<span class="fc" id="L44">    public static final Fn&lt;String, Integer&gt; toInt = new Fn&lt;String, Integer&gt;() {</span>
<span class="fc bfc" id="L45" title="All 2 branches covered.">        @Override public Integer $(String numeric) { return numeric != null ? Integer.valueOf(numeric) : 0; }};</span>


    /**
     * Converts a string to a &lt;code&gt;long&lt;/code&gt; value using {@link Long#valueOf(String)}.
     * If the string is &lt;code&gt;null&lt;/code&gt;, 0 is yielded.
     */
<span class="fc" id="L52">    public static final Fn&lt;String, Long&gt; toLong = new Fn&lt;String, Long&gt;() {</span>
<span class="fc bfc" id="L53" title="All 2 branches covered.">        @Override public Long $(String numeric) { return numeric != null ? Long.valueOf(numeric) : 0; }};</span>


    /**
     * Converts a string to a &lt;code&gt;double&lt;/code&gt; value using {@link Double#valueOf(String)}.
     * If the string is &lt;code&gt;null&lt;/code&gt;, 0 is yielded.
     */
<span class="fc" id="L60">    public static final Fn&lt;String, Double&gt; toDouble = new Fn&lt;String, Double&gt;() {</span>
<span class="fc bfc" id="L61" title="All 2 branches covered.">        @Override public Double $(String decimalValue) { return decimalValue != null ? Double.valueOf(decimalValue) : 0; }};</span>


    /**
     * Splits a string into characters.
     */
<span class="fc" id="L67">    public static final Fn&lt;String, Iterable&lt;Character&gt;&gt; toChars = new Fn&lt;String, Iterable&lt;Character&gt;&gt;() {</span>
<span class="fc" id="L68">        @Override public Iterable&lt;Character&gt; $(String value) { return Iterate.on(value); }};</span>


    /**
     * Yields the bytes of a String.
     * @see String#getBytes()
     */
<span class="fc" id="L75">    public static final Fn&lt;String, byte[]&gt; bytes = new DefaultIfArgIsNull&lt;String, byte[]&gt;(new byte[0]) {</span>
        @Override public byte[] orElse(String s) {
            try {
<span class="fc" id="L78">                return s.getBytes(Implicits.getEncoding());</span>
<span class="fc" id="L79">            } catch (UnsupportedEncodingException e) {</span>
<span class="fc" id="L80">                throw asRuntimeException(e);</span>
            }
        }
    };




    /**
     * A blank string is either &lt;code&gt;null&lt;/code&gt;, empty, or
     * all characters {@link Chars#whitespace are whitespace}.
     */
<span class="fc" id="L92">    public static final Predicate&lt;String&gt; blank = where(toChars, all(whitespace));</span>


    /**
     * A nonblank string has at least one character, and must contain at least
     * one character which is {@link Chars#whitespace not whitespace}.
     */
<span class="fc" id="L99">    public static final Predicate&lt;String&gt; nonblank = where(toChars, exists(not(whitespace)));</span>


    /**
     * A numeric string must have at least one character, and all of them
     * must be {@link Chars#digit digits}.
     */
<span class="fc" id="L106">    public static final Predicate&lt;String&gt; numeric = nonblankAllChars(digit);</span>


    /**
     * Alphanumeric strings are at least one character, and all
     * {@link Chars#digit digits} and/or {@link Chars#letter letters}.
     */
<span class="fc" id="L113">    public static final Predicate&lt;String&gt; alphanumeric = nonblankAllChars(letterOrDigit);</span>


    /**
     * Alphabetic strings are at least one character, and all {@link Chars#letter letters}.
     */
<span class="fc" id="L119">    public static final Predicate&lt;String&gt; alphabetic = nonblankAllChars(letter);</span>


    /**
     * Predicate verifying that all characters in a string satifies a given predicate.
     *
     * @param valid The predicate evaluating all characters in a string.
     */
    public static final Predicate&lt;String&gt; allChars(Predicate&lt;Character&gt; valid) {
<span class="fc" id="L128">        return where(toChars, all(valid)); }</span>

    /**
     * Predicate verifying that strings are {@link #nonblank not blank} and
     * each char satisfies a given predicate.
     *
     * @param valid
     */
    public static final Predicate&lt;String&gt; nonblankAllChars(Predicate&lt;Character&gt; valid) {
<span class="fc" id="L137">        return both(nonblank).and(allChars(valid)); }</span>


    /**
     * Trims a string, removing all leading and trailing whitespace.
     */
<span class="fc" id="L143">    public static final Fn&lt;String, String&gt; trimmed = new NullIfArgIsNull&lt;String, String&gt;() {</span>
<span class="fc" id="L144">        @Override protected String orElse(String s) { return s.trim(); }};</span>


    /**
     * Convert a string to {@link String#toLowerCase() lower case}.
     */
<span class="fc" id="L150">    public static final Fn&lt;String, String&gt; lowerCased = new NullIfArgIsNull&lt;String, String&gt;() {</span>
<span class="fc" id="L151">        @Override protected String orElse(String s) { return s.toLowerCase(Implicits.getLocale()); }};</span>


    /**
     * Convert a string to {@link String#toUpperCase() upper case}
     */
<span class="fc" id="L157">    public static final Fn&lt;String, String&gt; upperCased = new NullIfArgIsNull&lt;String, String&gt;() {</span>
<span class="fc" id="L158">        @Override protected String orElse(String s) { return s.toUpperCase(Implicits.getLocale()); }};</span>


    /**
     * Gives the length of a string, i.e. the amount of characters. &lt;code&gt;null&lt;/code&gt;
     * yields length 0.
     */
<span class="fc" id="L165">    public static final Fn&lt;String, Integer&gt; length = new Fn&lt;String, Integer&gt;() {</span>
<span class="fc bfc" id="L166" title="All 2 branches covered.">        @Override public Integer $(String s) { return s != null ? s.length() : 0; }};</span>


    /**
     * Evaluate if strings are of a exact length.
     * &lt;code&gt;null&lt;code&gt;s are considered to have length zero.
     */
<span class="fc" id="L173">    public static final Predicate&lt;String&gt; hasLength(int exactLength) { return hasLength(equalTo(exactLength)); }</span>


    /**
     * Evaluate if strings have accepted lengths.
     * &lt;code&gt;null&lt;code&gt;s are considered to have length zero.
     *
     * @param accepted The predicate evaluating accepted length.
     * @return The predicate evaluating string length.
     */
<span class="fc" id="L183">    public static final Predicate&lt;String&gt; hasLength(Predicate&lt;? super Integer&gt; accepted) { return where(length, accepted); }</span>


    /**
     * Concatenate a string with the {@link Object#toString() string representation}
     * of an arbitrary object, i.e. &lt;em&gt;reduces&lt;/em&gt; two strings to one.
     */
<span class="fc" id="L190">    public static final Fn2&lt;Object, Object, String&gt; concat = new Fn2&lt;Object, Object, String&gt;() {</span>
<span class="fc bfc" id="L191" title="All 2 branches covered.">        String emptyIfNull(Object o) { return (o != null? String.valueOf(o) : &quot;&quot;); }</span>
<span class="fc" id="L192">        @Override public String $(Object acc, Object c) { return emptyIfNull(acc) + emptyIfNull(c); }};</span>



    /**
     * Yields the given string with its characters in reversed order.
     */
<span class="fc" id="L199">    public static final Fn&lt;String, String&gt; reversed = new NullIfArgIsNull&lt;String, String&gt;() {</span>
<span class="fc" id="L200">        @Override protected String orElse(String s) { return new StringBuilder(s).reverse().toString(); }};</span>




    /**
     * Determines if a substring is present in a string. A string never contains &lt;code&gt;null&lt;/code&gt;,
     * nor does &lt;code&gt;null&lt;/code&gt; contain any substring.
     *
     * @param charSequence The substring to find.
     * @return The predicate.
     */
    public static Predicate&lt;String&gt; contains(final CharSequence charSequence) {
<span class="fc bfc" id="L213" title="All 2 branches covered.">        return charSequence == null ? Always.&lt;String&gt;no() : new FalseIfNull&lt;String&gt;() {</span>
<span class="fc" id="L214">        @Override protected boolean orElse(String string) { return string.contains(charSequence); }}; }</span>


    /**
     * Determines if a string starts with a given prefix string.
     *
     * @param prefix The prefix.
     * @return The predicate.
     */
    public static Predicate&lt;String&gt; startsWith(final String prefix) {
<span class="fc bfc" id="L224" title="All 2 branches covered.">        return prefix == null ? Always.&lt;String&gt;no() : new FalseIfNull&lt;String&gt;() {</span>
<span class="fc" id="L225">        @Override protected boolean orElse(String string) { return string.startsWith(prefix); }}; }</span>


    /**
     * Determines if a string ends with a given suffix string.
     *
     * @param suffix The suffix.
     * @return The predicate.
     */
    public static Predicate&lt;String&gt; endsWith(final String suffix) {
<span class="fc bfc" id="L235" title="All 2 branches covered.">        return suffix == null ? Always.&lt;String&gt;no() : new FalseIfNull&lt;String&gt;() {</span>
<span class="fc" id="L236">        @Override protected boolean orElse(String string) { return string.endsWith(suffix); }}; }</span>


    /**
     * Does a {@link String#matches(String) regular expression match} on strings.
     *
     * @param regex The regular expression to use for matching.
     * @return the predicate.
     */
    public static Predicate&lt;String&gt; matches(final String regex) {
<span class="fc bfc" id="L246" title="All 2 branches covered.">        return regex == null ? Always.&lt;String&gt;no() : new FalseIfNull&lt;String&gt;() {</span>
<span class="fc" id="L247">        @Override protected boolean orElse(String string) { return string.matches(regex); }};}</span>


    /**
     * Create a new strings by prepending a prefix.
     * @param prefix the prefix to prepend
     */
<span class="fc" id="L254">    public static Fn&lt;Object, String&gt; prepend(String prefix) { return Apply.partially(concat).of(prefix); }</span>


    /**
     * Create a new strings by appending a suffix.
     * @param suffix the suffix to append
     */
<span class="fc" id="L261">    public static Fn&lt;Object, String&gt; append(String suffix) { return Apply.partially(argsReversed(concat)).of(suffix); }</span>


    /**
     * Extract substring from strings. As
     * this function simply delegates to {@link String#substring(int, int)}, it
     * may throw an {@link IndexOutOfBoundsException} if the given indexes
     * are invalid.
     *
     * @param beginIndex The index of the first character to include.
     * @param endIndex The index to end the extraction.
     */
    public static Fn&lt;String, String&gt; substring(final int beginIndex, final int endIndex) {
<span class="fc bfc" id="L274" title="All 4 branches covered.">        if (beginIndex &lt; 0 || endIndex &lt; 0)</span>
<span class="fc" id="L275">            return alwaysThrow(new StringIndexOutOfBoundsException(</span>
                    &quot;Cannot extract substring using negative index. &quot; +
                    &quot;beginIndex: &quot; + beginIndex + &quot;, endIndex: &quot; + endIndex));
<span class="fc" id="L278">        return substring(always(beginIndex), always(endIndex));</span>
    }

    public static Fn&lt;String, String&gt; substring(final Fn&lt;? super String, Integer&gt; beginIndex, final Fn&lt;? super String, Integer&gt; endIndex) {
<span class="fc" id="L282">        return new NullIfArgIsNull&lt;String, String&gt;() { @Override public String orElse(String s) {</span>
<span class="fc" id="L283">            return optional(s).map(before(endIndex)).map(from(beginIndex)).getOrElse(null);</span>
        }};
    }


    /**
     * Get at most a given amount of the first characters of strings.
     * If the string is shorter than the amount, the original string is returned.
     */
    public static Fn&lt;String, String&gt; first(final int charAmount) {
<span class="fc" id="L293">        return new Fn&lt;String, String&gt;() {</span>
            @Override public String $(String s) {
<span class="fc bfc" id="L295" title="All 2 branches covered.">                if (s == null) return &quot;&quot;;</span>
<span class="fc bfc" id="L296" title="All 2 branches covered.">                return (charAmount &gt; s.length()) ? s : s.substring(0, charAmount);</span>
            }};
    }


    /**
     * Get at most a given amount of the last characters of strings.
     * If the string is shorter than the amount, the original string is returned.
     */
    public static Fn&lt;String, String&gt; last(final int charAmount) {
<span class="fc" id="L306">        return new Fn&lt;String, String&gt;() {</span>
            @Override public String $(String s) {
<span class="fc bfc" id="L308" title="All 2 branches covered.">                if (s == null) return &quot;&quot;;</span>
<span class="fc bfc" id="L309" title="All 2 branches covered.">                return (charAmount &gt; s.length()) ? s : s.substring(s.length() - charAmount, s.length());</span>
            }};
    }


    /**
     * Insert strings in between a prefix and a suffix.
     *
     * @param prefix The prefix to appear before the string.
     * @param suffix The suffix to appear after the string
     */
    public static Fn&lt;Object,String&gt; inBetween(final String prefix, final String suffix) {
<span class="fc" id="L321">        return Base.first(prepend(prefix)).then(append(suffix)); }</span>


    /**
     * Repeats a string a given amount of times.
     *
     * @param times The amount of times to repeat the string.
     */
<span class="fc" id="L329">    public static Fn&lt;String, String&gt; repeat(final int times) { return new NullIfArgIsNull&lt;String, String&gt;() {</span>
<span class="fc" id="L330">        @Override public String orElse(String s) { return on(asList(s)).repeat(times).join(); }}; }</span>


    /**
     * Repeats a string, insterting given separator, a given amount of times.
     *
     * @param times The amount of times to repeat the string.
     * @param separator The separator string to insert between the repeating strings.
     */
    public static Fn&lt;String, String&gt; repeat(final int times, final String separator) {
<span class="fc" id="L340">        return new NullIfArgIsNull&lt;String, String&gt;() {</span>
<span class="fc" id="L341">            @Override public String orElse(String s) { return on(asList(s)).repeat(times).join(separator); }}; }</span>



    /**
     * Inside strings, searches for the &lt;em&gt;first&lt;/em&gt; occurence of a substring, and yields the
     * rest of the string &lt;em&gt;after&lt;/em&gt; the substring occurence, not including the
     * substring itself.
     * &lt;p&gt;
     * Passing &lt;code&gt;null&lt;/code&gt; to the {@link Fn} always yields &lt;code&gt;null&lt;/code&gt;
     * &lt;/p&gt;
     * &lt;p&gt;
     * If the substring is not found (or it is &lt;code&gt;null&lt;/code&gt;), then &lt;code&gt;null&lt;/code&gt; is returned.
     * &lt;/p&gt;&lt;p&gt;
     * If the substring is the empty string, the original string is returned.
     * &lt;/p&gt;
     *
     * @param substring the substring to search for.
     */
    public static Fn&lt;String, String&gt; after(final String substring) {
<span class="fc bfc" id="L361" title="All 4 branches covered.">        if (substring == null || substring.isEmpty()) return NOP.fn();</span>
<span class="fc" id="L362">        return from(Base.first(indexOf(substring)).then(add(substring.length())));</span>
    }


    /**
     * Inside strings, searches for the &lt;em&gt;last&lt;/em&gt; occurence of a substring, and yields the
     * rest of the string &lt;em&gt;after&lt;/em&gt; the substring occurence, not including the
     * substring itself.
     * &lt;p&gt;
     * Passing &lt;code&gt;null&lt;/code&gt; to the {@link Fn} always yields &lt;code&gt;null&lt;/code&gt;
     * &lt;/p&gt;
     * &lt;p&gt;
     * If the substring is not found, or if it is &lt;code&gt;null&lt;/code&gt;, then &lt;code&gt;null&lt;/code&gt; is returned.
     * If the substring is empty, the empty string is returned.
     * &lt;/p&gt;
     *
     * @param substring the substring to search for.
     */
    public static Fn&lt;String, String&gt; afterLast(final String substring) {
<span class="fc bfc" id="L381" title="All 4 branches covered.">        if (substring == null || substring.isEmpty()) return passThruIfNullOrElseEmptyString;</span>
<span class="fc" id="L382">        return from(Base.first(lastIndexOf(substring)).then(add(substring.length())));</span>
    }



    /**
     * Yields substrings &lt;em&gt;from&lt;/em&gt; a position index.
     * @see #from(Fn)
     */
<span class="fc" id="L391">    public static Fn&lt;String, String&gt; from(int index) { return from(always(index)); }</span>



    /**
     * Yields substrings &lt;em&gt;from&lt;/em&gt; a position index. If the given index
     * {@link Fn} yields &lt;code&gt;null&lt;/code&gt;, then &lt;code&gt;null&lt;/code&gt; is returned.
     * If a positive index out of bounds with the length of the string
     * is yielded, the empty string is returned.
     *
     * &lt;p&gt;A negative index value is invalid and will throw an {@link StringIndexOutOfBoundsException}.&lt;/p&gt;
     * &lt;p&gt;Passing the &lt;code&gt;null&lt;/code&gt;-String always yields &lt;code&gt;null&lt;/code&gt;.&lt;/p&gt;
     *
     * @param index The {@link Fn} to resolve the index.
     */
    public static Fn&lt;String, String&gt; from(final Fn&lt;? super String, Integer&gt; index) {
<span class="fc" id="L407">        return new NullIfArgIsNull&lt;String, String&gt;() {</span>
            @Override
            protected String orElse(String s) {
<span class="fc" id="L410">                Integer idx = index.$(s);</span>
<span class="fc bfc" id="L411" title="All 2 branches covered.">                if (idx == null) return null;</span>
<span class="fc bfc" id="L412" title="All 2 branches covered.">                if (idx &gt;= s.length()) return &quot;&quot;;</span>
<span class="fc" id="L413">                return s.substring(idx);</span>
            }};
    }





    /**
     * Inside strings, searches for the &lt;em&gt;first&lt;/em&gt; occurence of a substring, and yields the
     * the string &lt;em&gt;before&lt;/em&gt; the substring occurence, not including the
     * substring itself.
     * &lt;p&gt;
     * Passing &lt;code&gt;null&lt;/code&gt; to the {@link Fn} always yields &lt;code&gt;null&lt;/code&gt;
     * &lt;/p&gt;
     * &lt;p&gt;
     * If the substring is &lt;code&gt;null&lt;/code&gt;, the original string is returned.
     * If the substring is not found, &lt;code&gt;null&lt;/code&gt; is returned.
     * &lt;/p&gt;&lt;p&gt;
     * If the substring is the empty string, or found from the beginning of the string, the empty string is returned.
     * &lt;/p&gt;
     *
     * @param substring the substring to search for.
     */
    public static Fn&lt;String, String&gt; before(final String substring) {
<span class="fc bfc" id="L438" title="All 2 branches covered.">        return substring == null ? NOP.&lt;String&gt;fn() : before(indexOf(substring));</span>
    }


    /**
     * Inside strings, searches for the &lt;em&gt;last&lt;/em&gt; occurence of a substring, and yields the
     * the string &lt;em&gt;before&lt;/em&gt; the substring occurence, not including the
     * substring itself.
     * &lt;p&gt;
     * Passing &lt;code&gt;null&lt;/code&gt; to the {@link Fn} always yields &lt;code&gt;null&lt;/code&gt;
     * &lt;/p&gt;&lt;p&gt;
     * If the substring is &lt;code&gt;null&lt;/code&gt; or empty, the original string is returned.
     * If the substring is not found, &lt;code&gt;null&lt;/code&gt; is returned.
     * &lt;/p&gt;
     *
     * @param substring the substring to search for.
     */
    public static Fn&lt;String, String&gt; beforeLast(final String substring) {
<span class="fc bfc" id="L456" title="All 2 branches covered.">        return substring != null ? before(lastIndexOf(substring)) : NOP.&lt;String&gt;fn();</span>
    }


    /**
     * Yields substrings &lt;em&gt;before&lt;/em&gt; a position index.
     * @see #before(Fn)
     */
<span class="fc" id="L464">    public static Fn&lt;String, String&gt; before(int index) { return before(always(index)); }</span>


    /**
     * Yields substrings &lt;em&gt;before&lt;/em&gt; a position index. If the given index
     * {@link Fn} yields &lt;code&gt;null&lt;/code&gt;, or a positive index out of bounds
     * with the length of the string, the original string is returned.
     *
     * &lt;p&gt;A negative index is invalid and will throw an {@link StringIndexOutOfBoundsException}.&lt;/p&gt;
     * &lt;p&gt;Passing the &lt;code&gt;null&lt;/code&gt;-String always yields &lt;code&gt;null&lt;/code&gt;.&lt;/p&gt;
     *
     * @param index The {@link Fn} to resolve the index.
     */
    public static Fn&lt;String, String&gt; before(final Fn&lt;? super String, Integer&gt; index) {
<span class="fc" id="L478">        return new NullIfArgIsNull&lt;String, String&gt;() {</span>
            @Override
            protected String orElse(String s) {
<span class="fc" id="L481">                Integer idx = index.$(s);</span>
<span class="fc bfc" id="L482" title="All 2 branches covered.">                if (idx == null) return null;</span>
<span class="fc bfc" id="L483" title="All 2 branches covered.">                if (idx &gt;= s.length()) return s;</span>
<span class="fc" id="L484">                return s.substring(0, idx);</span>
            }};
    }


    /**
     * Yield the string _between_ two substrings. The substrings will be the first possible
     * matches, which means &lt;code&gt;between(&quot;x&quot;, &quot;y&quot;)&lt;/code&gt; applied to the string
     * &lt;code&gt;&quot;xxyy&quot;&lt;/code&gt; will yield &lt;code&gt;&quot;x&quot;&lt;/code&gt;.
     *
     * @param openSubstring
     * @param closeSubstring
     */
    public static Fn&lt;String,String&gt; between(String openSubstring, String closeSubstring) {
<span class="fc bfc" id="L498" title="All 4 branches covered.">        if (openSubstring == null || closeSubstring == null) return always(null);</span>
<span class="fc" id="L499">        return Base.first(after(openSubstring)).then(before(closeSubstring));</span>
    }


    /**
     * Yield the string _between_ two outermost substrings. This means
     * &lt;code&gt;betweenOuter(&quot;x&quot;, &quot;y&quot;)&lt;/code&gt; applied to the string
     * &lt;code&gt;&quot;xxyy&quot;&lt;/code&gt; will yield &lt;code&gt;&quot;xy&quot;&lt;/code&gt;.
     *
     * @param openSubstring
     * @param closeSubstring
     */
    public static Fn&lt;String,String&gt; betweenOuter(String openSubstring, String closeSubstring) {
<span class="fc bfc" id="L512" title="All 4 branches covered.">        if (openSubstring == null || closeSubstring == null) return always(null);</span>
<span class="fc" id="L513">        return Base.first(after(openSubstring)).then(beforeLast(closeSubstring));</span>
    }


    /**
     * Yield all strings occurring _between_ two substrings.
     *
     * @param openSubstring
     * @param closeSubstring
     */
    public static Fn&lt;String, Iterable&lt;String&gt;&gt; allBetween(final String openSubstring, final String closeSubstring) {
<span class="fc bfc" id="L524" title="All 4 branches covered.">        if (openSubstring == null || closeSubstring == null) return always((Iterable&lt;String&gt;) Collections.&lt;String&gt;emptySet());</span>
<span class="fc bfc" id="L525" title="All 4 branches covered.">        if (&quot;&quot;.equals(openSubstring) &amp;&amp; &quot;&quot;.equals(closeSubstring)) return alwaysThrow(new IllegalArgumentException(</span>
                &quot;Extracting all strings between two empty strings would yield an infinite amount of empty strings!&quot;));
<span class="fc" id="L527">        return new NullIfArgIsNull&lt;String, Iterable&lt;String&gt;&gt;() {</span>
<span class="fc" id="L528">            final Fn&lt;String, String&gt; firstSubstring = between(openSubstring, closeSubstring);</span>
            @Override
            protected Iterable&lt;String&gt; orElse(String s) {
<span class="fc" id="L531">                Optional&lt;String&gt; original = optional(s);</span>
<span class="fc" id="L532">                Optional&lt;String&gt; first = original.map(firstSubstring);</span>
<span class="fc bfc" id="L533" title="All 2 branches covered.">                if (!first.isSome()) return Collections.emptySet();</span>
<span class="fc" id="L534">                Optional&lt;String&gt; rest = original.map(nonblank, after(first.map(inBetween(openSubstring, closeSubstring)).getOrElse(null)));</span>
<span class="fc" id="L535">                return first.append(this.$(rest.getOrElse(&quot;&quot;)));</span>
            }};
    }



    /**
     * Yields index position of first occurence of a &lt;code&gt;char&lt;/code&gt;, or &lt;code&gt;null&lt;/code&gt; if the
     * &lt;code&gt;char&lt;/code&gt; cannot be found.
     *
     * @see String#indexOf(int)
     */
    public static Fn&lt;String, Integer&gt; indexOf(final char c) {
<span class="fc" id="L548">        return new NullIfArgIsNull&lt;String, Integer&gt;() {</span>
            @Override protected Integer orElse(String s) {
<span class="fc" id="L550">                int index = s.indexOf(c);</span>
<span class="fc bfc" id="L551" title="All 2 branches covered.">                return index &gt;= 0 ? index : null;</span>
            }};
    }


    /**
     * Yields index position of last occurence of a &lt;code&gt;char&lt;/code&gt;, or &lt;code&gt;null&lt;/code&gt; if the
     * &lt;code&gt;char&lt;/code&gt; cannot be found.
     *
     * @see String#indexOf(int)
     */
<span class="fc" id="L562">    public static Fn&lt;String, Integer&gt; lastIndexOf(final char c) { return new NullIfArgIsNull&lt;String, Integer&gt;() {</span>
        @Override protected Integer orElse(String s) {
<span class="fc" id="L564">            int index = s.lastIndexOf(c);</span>
<span class="fc bfc" id="L565" title="All 2 branches covered.">            return index &gt;= 0 ? index : null;</span>
        }};
    }


    /**
     * Yields index position of first occurence of a substring, or &lt;code&gt;null&lt;/code&gt; if the substring cannot
     * be found.
     *
     * @see String#indexOf(String)
     */
    public static Fn&lt;String, Integer&gt; indexOf(final String substring) {
<span class="fc bfc" id="L577" title="All 2 branches covered.">        if (substring == null) return always(null);</span>
<span class="fc" id="L578">        return new NullIfArgIsNull&lt;String, Integer&gt;() {</span>
            @Override protected Integer orElse(String s) {
<span class="fc" id="L580">                int index = s.indexOf(substring);</span>
<span class="fc bfc" id="L581" title="All 2 branches covered.">                return index &gt;= 0 ? index : null;</span>
            }};
    }



    /**
     * Yields index position of last occurence of a substring, or &lt;code&gt;null&lt;/code&gt; if the substring cannot
     * be found.
     *
     * @see String#indexOf(String)
     */
    public static Fn&lt;String, Integer&gt; lastIndexOf(final String substring) {
<span class="fc bfc" id="L594" title="All 2 branches covered.">        if (substring == null) return always(null);</span>
<span class="fc" id="L595">        return new NullIfArgIsNull&lt;String, Integer&gt;() {</span>
            @Override protected Integer orElse(String s) {
<span class="fc" id="L597">                int index = s.lastIndexOf(substring);</span>
<span class="fc bfc" id="L598" title="All 2 branches covered.">                return index &gt;= 0 ? index : null;</span>
            }};
    }


<span class="fc" id="L603">    private static final Fn&lt;String, String&gt; passThruIfNullOrElseEmptyString = new NullIfArgIsNull&lt;String, String&gt;() {</span>
<span class="fc" id="L604">        @Override protected String orElse(String s) { return &quot;&quot;; }};</span>

<span class="fc" id="L606">    private Strings() {}</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.0.201403182114</span></div></body></html>