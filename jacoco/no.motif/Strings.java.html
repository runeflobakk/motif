<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Strings.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Motif</a> &gt; <a href="index.source.html" class="el_package">no.motif</a> &gt; <span class="el_source">Strings.java</span></div><h1>Strings.java</h1><pre class="source lang-java linenums">package no.motif;

import static no.motif.Base.all;
import static no.motif.Base.always;
import static no.motif.Base.alwaysThrow;
import static no.motif.Base.both;
import static no.motif.Base.equalTo;
import static no.motif.Base.exists;
import static no.motif.Base.not;
import static no.motif.Base.notNull;
import static no.motif.Base.when;
import static no.motif.Base.where;
import static no.motif.Chars.digit;
import static no.motif.Chars.letter;
import static no.motif.Chars.letterOrDigit;
import static no.motif.Chars.whitespace;
import static no.motif.Exceptions.asRuntimeException;
import static no.motif.Ints.add;
import static no.motif.Iterate.on;
import static no.motif.Singular.optional;
import static no.motif.f.Apply.argsReversed;

import java.io.UnsupportedEncodingException;
import java.util.Collections;

import no.motif.f.Apply;
import no.motif.f.Fn;
import no.motif.f.Fn2;
import no.motif.f.Predicate;
import no.motif.f.Predicate.Always;
import no.motif.f.base.FalseIfNull;
import no.motif.iter.SplitOnCharacter;
import no.motif.iter.SplitOnSubstring;
import no.motif.single.Optional;

/**
 * Functions operating on {@link String strings}.
 */
public final class Strings {

    /**
     * Converts a string to a &lt;code&gt;int&lt;/code&gt; value using {@link Integer#valueOf(String)}.
     * If the string is &lt;code&gt;null&lt;/code&gt;, 0 is yielded.
     */
<span class="fc" id="L45">    public static final Fn&lt;String, Integer&gt; toInt = new Fn&lt;String, Integer&gt;() {</span>
<span class="fc bfc" id="L46" title="All 2 branches covered.">        @Override public Integer $(String numeric) { return numeric != null ? Integer.valueOf(numeric) : 0; }};</span>


    /**
     * Converts a string to a &lt;code&gt;long&lt;/code&gt; value using {@link Long#valueOf(String)}.
     * If the string is &lt;code&gt;null&lt;/code&gt;, 0 is yielded.
     */
<span class="fc" id="L53">    public static final Fn&lt;String, Long&gt; toLong = new Fn&lt;String, Long&gt;() {</span>
<span class="fc bfc" id="L54" title="All 2 branches covered.">        @Override public Long $(String numeric) { return numeric != null ? Long.valueOf(numeric) : 0; }};</span>


    /**
     * Converts a string to a &lt;code&gt;double&lt;/code&gt; value using {@link Double#valueOf(String)}.
     * If the string is &lt;code&gt;null&lt;/code&gt;, 0 is yielded.
     */
<span class="fc" id="L61">    public static final Fn&lt;String, Double&gt; toDouble = new Fn&lt;String, Double&gt;() {</span>
<span class="fc bfc" id="L62" title="All 2 branches covered.">        @Override public Double $(String decimalValue) { return decimalValue != null ? Double.valueOf(decimalValue) : 0; }};</span>


    /**
     * Splits a string into characters.
     */
<span class="fc" id="L68">    public static final Fn&lt;String, Iterable&lt;Character&gt;&gt; toChars = new Fn&lt;String, Iterable&lt;Character&gt;&gt;() {</span>
<span class="fc" id="L69">        @Override public Iterable&lt;Character&gt; $(String value) { return Iterate.on(value); }};</span>


    /**
     * Yields the bytes of a String.
     * @see String#getBytes()
     */
<span class="fc" id="L76">    public static final Fn&lt;String, Iterable&lt;Byte&gt;&gt; bytes = when(notNull, new Fn&lt;String, Iterable&lt;Byte&gt;&gt;() {</span>
        @Override public Iterable&lt;Byte&gt; $(String s) {
            try {
<span class="fc" id="L79">                return Iterate.on(s.getBytes(Implicits.getEncoding()));</span>
<span class="fc" id="L80">            } catch (UnsupportedEncodingException e) {</span>
<span class="fc" id="L81">                throw asRuntimeException(e);</span>
            }
        }
    }).orElse(Iterate.&lt;Byte&gt;none());




    /**
     * A blank string is either &lt;code&gt;null&lt;/code&gt;, empty, or
     * all characters {@link Chars#whitespace are whitespace}.
     */
<span class="fc" id="L93">    public static final Predicate&lt;String&gt; blank = where(toChars, all(whitespace));</span>


    /**
     * A nonblank string has at least one character, and must contain at least
     * one character which is {@link Chars#whitespace not whitespace}.
     */
<span class="fc" id="L100">    public static final Predicate&lt;String&gt; nonblank = where(toChars, exists(not(whitespace)));</span>


    /**
     * A numeric string must have at least one character, and all of them
     * must be {@link Chars#digit digits}.
     */
<span class="fc" id="L107">    public static final Predicate&lt;String&gt; numeric = nonblankAllChars(digit);</span>


    /**
     * Alphanumeric strings are at least one character, and all
     * {@link Chars#digit digits} and/or {@link Chars#letter letters}.
     */
<span class="fc" id="L114">    public static final Predicate&lt;String&gt; alphanumeric = nonblankAllChars(letterOrDigit);</span>


    /**
     * Alphabetic strings are at least one character, and all {@link Chars#letter letters}.
     */
<span class="fc" id="L120">    public static final Predicate&lt;String&gt; alphabetic = nonblankAllChars(letter);</span>


    /**
     * Predicate verifying that all characters in a string satifies a given predicate.
     *
     * @param valid The predicate evaluating all characters in a string.
     */
    public static final Predicate&lt;String&gt; allChars(Predicate&lt;Character&gt; valid) {
<span class="fc" id="L129">        return where(toChars, all(valid)); }</span>

    /**
     * Predicate verifying that strings are {@link #nonblank not blank} and
     * each char satisfies a given predicate.
     *
     * @param valid
     */
    public static final Predicate&lt;String&gt; nonblankAllChars(Predicate&lt;Character&gt; valid) {
<span class="fc" id="L138">        return both(nonblank).and(allChars(valid)); }</span>


    /**
     * Trims a string, removing all leading and trailing whitespace.
     */
<span class="fc" id="L144">    public static final Fn&lt;String, String&gt; trimmed = when(notNull, new Fn&lt;String, String&gt;() {</span>
<span class="fc" id="L145">        @Override public String $(String s) { return s.trim(); }});</span>


    /**
     * Convert a string to {@link String#toLowerCase() lower case}.
     */
<span class="fc" id="L151">    public static final Fn&lt;String, String&gt; lowerCased = when(notNull, new Fn&lt;String, String&gt;() {</span>
<span class="fc" id="L152">        @Override public String $(String s) { return s.toLowerCase(Implicits.getLocale()); }});</span>


    /**
     * Convert a string to {@link String#toUpperCase() upper case}
     */
<span class="fc" id="L158">    public static final Fn&lt;String, String&gt; upperCased = when(notNull, new Fn&lt;String, String&gt;() {</span>
<span class="fc" id="L159">        @Override public String $(String s) { return s.toUpperCase(Implicits.getLocale()); }});</span>


    /**
     * Gives the length of a string, i.e. the amount of characters. &lt;code&gt;null&lt;/code&gt;
     * yields length 0.
     */
<span class="fc" id="L166">    public static final Fn&lt;String, Integer&gt; length = when(notNull, new Fn&lt;String, Integer&gt;() {</span>
<span class="fc" id="L167">        @Override public Integer $(String s) { return s.length(); }}).orElse(0);</span>


    /**
     * Evaluate if strings are of a exact length.
     * &lt;code&gt;null&lt;code&gt;s are considered to have length zero.
     */
<span class="fc" id="L174">    public static final Predicate&lt;String&gt; hasLength(int exactLength) { return hasLength(equalTo(exactLength)); }</span>


    /**
     * Evaluate if strings have accepted lengths.
     * &lt;code&gt;null&lt;code&gt;s are considered to have length zero.
     *
     * @param accepted The predicate evaluating accepted length.
     * @return The predicate evaluating string length.
     */
<span class="fc" id="L184">    public static final Predicate&lt;String&gt; hasLength(Predicate&lt;? super Integer&gt; accepted) { return where(length, accepted); }</span>


    /**
     * Concatenate a string with the {@link Object#toString() string representation}
     * of an arbitrary object, i.e. &lt;em&gt;reduces&lt;/em&gt; two strings to one.
     */
<span class="fc" id="L191">    public static final Fn2&lt;Object, Object, String&gt; concat = new Fn2&lt;Object, Object, String&gt;() {</span>
<span class="fc bfc" id="L192" title="All 2 branches covered.">        String emptyIfNull(Object o) { return (o != null? String.valueOf(o) : &quot;&quot;); }</span>
<span class="fc" id="L193">        @Override public String $(Object acc, Object c) { return emptyIfNull(acc) + emptyIfNull(c); }};</span>



    /**
     * Yields the given string with its characters in reversed order.
     */
<span class="fc" id="L200">    public static final Fn&lt;String, String&gt; reversed = when(notNull, new Fn&lt;String, String&gt;() {</span>
<span class="fc" id="L201">        @Override public String $(String s) { return new StringBuilder(s).reverse().toString(); }});</span>




    /**
     * Determines if a substring is present in a string. A string never contains &lt;code&gt;null&lt;/code&gt;,
     * nor does &lt;code&gt;null&lt;/code&gt; contain any substring.
     *
     * @param charSequence The substring to find.
     * @return The predicate.
     */
    public static Predicate&lt;String&gt; contains(final CharSequence charSequence) {
<span class="fc bfc" id="L214" title="All 2 branches covered.">        return charSequence == null ? Always.&lt;String&gt;no() : new FalseIfNull&lt;String&gt;() {</span>
<span class="fc" id="L215">        @Override protected boolean orElse(String string) { return string.contains(charSequence); }}; }</span>


    /**
     * Determines if a string starts with a given prefix string.
     *
     * @param prefix The prefix.
     * @return The predicate.
     */
    public static Predicate&lt;String&gt; startsWith(final String prefix) {
<span class="fc bfc" id="L225" title="All 2 branches covered.">        return prefix == null ? Always.&lt;String&gt;no() : new FalseIfNull&lt;String&gt;() {</span>
<span class="fc" id="L226">        @Override protected boolean orElse(String string) { return string.startsWith(prefix); }}; }</span>


    /**
     * Determines if a string ends with a given suffix string.
     *
     * @param suffix The suffix.
     * @return The predicate.
     */
    public static Predicate&lt;String&gt; endsWith(final String suffix) {
<span class="fc bfc" id="L236" title="All 2 branches covered.">        return suffix == null ? Always.&lt;String&gt;no() : new FalseIfNull&lt;String&gt;() {</span>
<span class="fc" id="L237">        @Override protected boolean orElse(String string) { return string.endsWith(suffix); }}; }</span>


    /**
     * Does a {@link String#matches(String) regular expression match} on strings.
     *
     * @param regex The regular expression to use for matching.
     * @return the predicate.
     */
    public static Predicate&lt;String&gt; matches(final String regex) {
<span class="fc bfc" id="L247" title="All 2 branches covered.">        return regex == null ? Always.&lt;String&gt;no() : new FalseIfNull&lt;String&gt;() {</span>
<span class="fc" id="L248">        @Override protected boolean orElse(String string) { return string.matches(regex); }};}</span>


    /**
     * Create a new strings by prepending a prefix.
     * @param prefix the prefix to prepend
     */
<span class="fc" id="L255">    public static Fn&lt;Object, String&gt; prepend(String prefix) { return Apply.partially(concat).of(prefix); }</span>


    /**
     * Create a new strings by appending a suffix.
     * @param suffix the suffix to append
     */
<span class="fc" id="L262">    public static Fn&lt;Object, String&gt; append(String suffix) { return Apply.partially(argsReversed(concat)).of(suffix); }</span>


    /**
     * Extract substring from strings. As
     * this function simply delegates to {@link String#substring(int, int)}, it
     * may throw an {@link IndexOutOfBoundsException} if the given indexes
     * are invalid.
     *
     * @param beginIndex The index of the first character to include.
     * @param endIndex The index to end the extraction.
     */
    public static Fn&lt;String, String&gt; substring(final int beginIndex, final int endIndex) {
<span class="fc bfc" id="L275" title="All 4 branches covered.">        if (beginIndex &lt; 0 || endIndex &lt; 0)</span>
<span class="fc" id="L276">            return alwaysThrow(new StringIndexOutOfBoundsException(</span>
                    &quot;Cannot extract substring using negative index. &quot; +
                    &quot;beginIndex: &quot; + beginIndex + &quot;, endIndex: &quot; + endIndex));
<span class="fc" id="L279">        return substring(always(beginIndex), always(endIndex));</span>
    }

    public static Fn&lt;String, String&gt; substring(final Fn&lt;? super String, Integer&gt; beginIndex, final Fn&lt;? super String, Integer&gt; endIndex) {
<span class="fc" id="L283">        return when(notNull, new Fn&lt;String, String&gt;() { @Override public String $(String s) {</span>
<span class="fc" id="L284">            return optional(s).map(before(endIndex)).map(from(beginIndex)).orNull();</span>
        }});
    }


    /**
     * Get at most a given amount of the first characters of strings.
     * If the string is shorter than the amount, the original string is returned.
     */
    public static Fn&lt;String, String&gt; first(final int charAmount) {
<span class="fc" id="L294">        return when(notNull, new Fn&lt;String, String&gt;() { @Override public String $(String s) {</span>
<span class="fc bfc" id="L295" title="All 2 branches covered.">                    return (charAmount &gt; s.length()) ? s : s.substring(0, charAmount);</span>
                }}).orElse(&quot;&quot;);
    }


    /**
     * Get at most a given amount of the last characters of strings.
     * If the string is shorter than the amount, the original string is returned.
     */
    public static Fn&lt;String, String&gt; last(final int charAmount) {
<span class="fc" id="L305">        return when(notNull, new Fn&lt;String, String&gt;() { @Override public String $(String s) {</span>
<span class="fc bfc" id="L306" title="All 2 branches covered.">                    return (charAmount &gt; s.length()) ? s : s.substring(s.length() - charAmount, s.length());</span>
                }}).orElse(&quot;&quot;);
    }


    /**
     * Insert strings in between a prefix and a suffix.
     *
     * @param prefix The prefix to appear before the string.
     * @param suffix The suffix to appear after the string
     */
    public static Fn&lt;Object,String&gt; inBetween(final String prefix, final String suffix) {
<span class="fc" id="L318">        return Base.first(prepend(prefix)).then(append(suffix)); }</span>


    /**
     * Repeats a string a given amount of times.
     *
     * @param times The amount of times to repeat the string.
     */
<span class="fc" id="L326">    public static Fn&lt;String, String&gt; repeat(final int times) { return when(notNull, new Fn&lt;String, String&gt;() {</span>
<span class="fc" id="L327">        @Override public String $(String s) { return on((Object) s).repeat(times).join(); }}); }</span>


    /**
     * Repeats a string, insterting given separator, a given amount of times.
     *
     * @param times The amount of times to repeat the string.
     * @param separator The separator string to insert between the repeating strings.
     */
    public static Fn&lt;String, String&gt; repeat(final int times, final String separator) {
<span class="fc" id="L337">        return when(notNull, new Fn&lt;String, String&gt;() {</span>
<span class="fc" id="L338">            @Override public String $(String s) { return on((Object) s).repeat(times).join(separator); }}); }</span>



    /**
     * Inside strings, searches for the &lt;em&gt;first&lt;/em&gt; occurence of a substring, and yields the
     * rest of the string &lt;em&gt;after&lt;/em&gt; the substring occurence, not including the
     * substring itself.
     * &lt;p&gt;
     * Passing &lt;code&gt;null&lt;/code&gt; to the {@link Fn} always yields &lt;code&gt;null&lt;/code&gt;
     * &lt;/p&gt;
     * &lt;p&gt;
     * If the substring is not found (or it is &lt;code&gt;null&lt;/code&gt;), then &lt;code&gt;null&lt;/code&gt; is returned.
     * &lt;/p&gt;&lt;p&gt;
     * If the substring is the empty string, the original string is returned.
     * &lt;/p&gt;
     *
     * @param substring the substring to search for.
     */
    public static Fn&lt;String, String&gt; after(final String substring) {
<span class="fc bfc" id="L358" title="All 4 branches covered.">        if (substring == null || substring.isEmpty()) return NOP.fn();</span>
<span class="fc" id="L359">        return from(Base.first(indexOf(substring)).then(add(substring.length())));</span>
    }


    /**
     * Inside strings, searches for the &lt;em&gt;last&lt;/em&gt; occurence of a substring, and yields the
     * rest of the string &lt;em&gt;after&lt;/em&gt; the substring occurence, not including the
     * substring itself.
     * &lt;p&gt;
     * Passing &lt;code&gt;null&lt;/code&gt; to the {@link Fn} always yields &lt;code&gt;null&lt;/code&gt;
     * &lt;/p&gt;
     * &lt;p&gt;
     * If the substring is not found, or if it is &lt;code&gt;null&lt;/code&gt;, then &lt;code&gt;null&lt;/code&gt; is returned.
     * If the substring is empty, the empty string is returned.
     * &lt;/p&gt;
     *
     * @param substring the substring to search for.
     */
    public static Fn&lt;String, String&gt; afterLast(final String substring) {
<span class="fc bfc" id="L378" title="All 4 branches covered.">        if (substring == null || substring.isEmpty()) return when(notNull, Base.&lt;String, String, String&gt;always(&quot;&quot;));</span>
<span class="fc" id="L379">        return from(Base.first(lastIndexOf(substring)).then(add(substring.length())));</span>
    }



    /**
     * Yields substrings &lt;em&gt;from&lt;/em&gt; a position index.
     * @see #from(Fn)
     */
<span class="fc" id="L388">    public static Fn&lt;String, String&gt; from(int index) { return from(always(index)); }</span>



    /**
     * Yields substrings &lt;em&gt;from&lt;/em&gt; a position index. If the given index
     * {@link Fn} yields &lt;code&gt;null&lt;/code&gt;, then &lt;code&gt;null&lt;/code&gt; is returned.
     * If a positive index out of bounds with the length of the string
     * is yielded, the empty string is returned.
     *
     * &lt;p&gt;A negative index value is invalid and will throw an {@link StringIndexOutOfBoundsException}.&lt;/p&gt;
     * &lt;p&gt;Passing the &lt;code&gt;null&lt;/code&gt;-String always yields &lt;code&gt;null&lt;/code&gt;.&lt;/p&gt;
     *
     * @param index The {@link Fn} to resolve the index.
     */
    public static Fn&lt;String, String&gt; from(final Fn&lt;? super String, Integer&gt; index) {
<span class="fc" id="L404">        return when(notNull, new Fn&lt;String, String&gt;() {</span>
            @Override
            public String $(String s) {
<span class="fc" id="L407">                Integer idx = index.$(s);</span>
<span class="fc bfc" id="L408" title="All 2 branches covered.">                if (idx == null) return null;</span>
<span class="fc bfc" id="L409" title="All 2 branches covered.">                if (idx &gt;= s.length()) return &quot;&quot;;</span>
<span class="fc" id="L410">                return s.substring(idx);</span>
            }});
    }





    /**
     * Inside strings, searches for the &lt;em&gt;first&lt;/em&gt; occurence of a substring, and yields the
     * the string &lt;em&gt;before&lt;/em&gt; the substring occurence, not including the
     * substring itself.
     * &lt;p&gt;
     * Passing &lt;code&gt;null&lt;/code&gt; to the {@link Fn} always yields &lt;code&gt;null&lt;/code&gt;
     * &lt;/p&gt;
     * &lt;p&gt;
     * If the substring is &lt;code&gt;null&lt;/code&gt;, the original string is returned.
     * If the substring is not found, &lt;code&gt;null&lt;/code&gt; is returned.
     * &lt;/p&gt;&lt;p&gt;
     * If the substring is the empty string, or found from the beginning of the string, the empty string is returned.
     * &lt;/p&gt;
     *
     * @param substring the substring to search for.
     */
    public static Fn&lt;String, String&gt; before(final String substring) {
<span class="fc bfc" id="L435" title="All 2 branches covered.">        return substring == null ? NOP.&lt;String&gt;fn() : before(indexOf(substring));</span>
    }


    /**
     * Inside strings, searches for the &lt;em&gt;last&lt;/em&gt; occurence of a substring, and yields the
     * the string &lt;em&gt;before&lt;/em&gt; the substring occurence, not including the
     * substring itself.
     * &lt;p&gt;
     * Passing &lt;code&gt;null&lt;/code&gt; to the {@link Fn} always yields &lt;code&gt;null&lt;/code&gt;
     * &lt;/p&gt;&lt;p&gt;
     * If the substring is &lt;code&gt;null&lt;/code&gt; or empty, the original string is returned.
     * If the substring is not found, &lt;code&gt;null&lt;/code&gt; is returned.
     * &lt;/p&gt;
     *
     * @param substring the substring to search for.
     */
    public static Fn&lt;String, String&gt; beforeLast(final String substring) {
<span class="fc bfc" id="L453" title="All 2 branches covered.">        return substring != null ? before(lastIndexOf(substring)) : NOP.&lt;String&gt;fn();</span>
    }


    /**
     * Yields substrings &lt;em&gt;before&lt;/em&gt; a position index.
     * @see #before(Fn)
     */
<span class="fc" id="L461">    public static Fn&lt;String, String&gt; before(int index) { return before(always(index)); }</span>


    /**
     * Yields substrings &lt;em&gt;before&lt;/em&gt; a position index. If the given index
     * {@link Fn} yields &lt;code&gt;null&lt;/code&gt;, or a positive index out of bounds
     * with the length of the string, the original string is returned.
     *
     * &lt;p&gt;A negative index is invalid and will throw an {@link StringIndexOutOfBoundsException}.&lt;/p&gt;
     * &lt;p&gt;Passing the &lt;code&gt;null&lt;/code&gt;-String always yields &lt;code&gt;null&lt;/code&gt;.&lt;/p&gt;
     *
     * @param index The {@link Fn} to resolve the index.
     */
    public static Fn&lt;String, String&gt; before(final Fn&lt;? super String, Integer&gt; index) {
<span class="fc" id="L475">        return when(notNull, new Fn&lt;String, String&gt;() {</span>
            @Override
            public String $(String s) {
<span class="fc" id="L478">                Integer idx = index.$(s);</span>
<span class="fc bfc" id="L479" title="All 2 branches covered.">                if (idx == null) return null;</span>
<span class="fc bfc" id="L480" title="All 2 branches covered.">                if (idx &gt;= s.length()) return s;</span>
<span class="fc" id="L481">                return s.substring(0, idx);</span>
            }});
    }


    /**
     * Yield the string _between_ two substrings. The substrings will be the first possible
     * matches, which means &lt;code&gt;between(&quot;x&quot;, &quot;y&quot;)&lt;/code&gt; applied to the string
     * &lt;code&gt;&quot;xxyy&quot;&lt;/code&gt; will yield &lt;code&gt;&quot;x&quot;&lt;/code&gt;.
     *
     * @param openSubstring
     * @param closeSubstring
     */
    public static Fn&lt;String,String&gt; between(String openSubstring, String closeSubstring) {
<span class="fc bfc" id="L495" title="All 4 branches covered.">        if (openSubstring == null || closeSubstring == null) return always(null);</span>
<span class="fc" id="L496">        return Base.first(after(openSubstring)).then(before(closeSubstring));</span>
    }


    /**
     * Yield the string _between_ two outermost substrings. This means
     * &lt;code&gt;betweenOuter(&quot;x&quot;, &quot;y&quot;)&lt;/code&gt; applied to the string
     * &lt;code&gt;&quot;xxyy&quot;&lt;/code&gt; will yield &lt;code&gt;&quot;xy&quot;&lt;/code&gt;.
     *
     * @param openSubstring
     * @param closeSubstring
     */
    public static Fn&lt;String,String&gt; betweenOuter(String openSubstring, String closeSubstring) {
<span class="fc bfc" id="L509" title="All 4 branches covered.">        if (openSubstring == null || closeSubstring == null) return always(null);</span>
<span class="fc" id="L510">        return Base.first(after(openSubstring)).then(beforeLast(closeSubstring));</span>
    }


    /**
     * Yield all strings occurring _between_ two substrings.
     *
     * @param openSubstring
     * @param closeSubstring
     */
    public static Fn&lt;String, Iterable&lt;String&gt;&gt; allBetween(final String openSubstring, final String closeSubstring) {
<span class="fc bfc" id="L521" title="All 4 branches covered.">        if (openSubstring == null || closeSubstring == null) return always((Iterable&lt;String&gt;) Collections.&lt;String&gt;emptySet());</span>
<span class="fc bfc" id="L522" title="All 4 branches covered.">        if (&quot;&quot;.equals(openSubstring) &amp;&amp; &quot;&quot;.equals(closeSubstring)) return alwaysThrow(new IllegalArgumentException(</span>
                &quot;Extracting all strings between two empty strings would yield an infinite amount of empty strings!&quot;));
<span class="fc" id="L524">        return when(notNull, new Fn&lt;String, Iterable&lt;String&gt;&gt;() {</span>
<span class="fc" id="L525">            final Fn&lt;String, String&gt; firstSubstring = between(openSubstring, closeSubstring);</span>
            @Override
            public Iterable&lt;String&gt; $(String s) {
<span class="fc" id="L528">                Optional&lt;String&gt; original = optional(s);</span>
<span class="fc" id="L529">                Optional&lt;String&gt; first = original.map(firstSubstring);</span>
<span class="fc bfc" id="L530" title="All 2 branches covered.">                if (!first.isSome()) return Collections.emptySet();</span>
<span class="fc" id="L531">                Optional&lt;String&gt; rest = original.map(nonblank, after(first.map(inBetween(openSubstring, closeSubstring)).orElse(null)));</span>
<span class="fc" id="L532">                return first.append(this.$(rest.orElse(&quot;&quot;)));</span>
            }});
    }



    /**
     * Yields index position of first occurence of a &lt;code&gt;char&lt;/code&gt;, or &lt;code&gt;null&lt;/code&gt;
     * if the &lt;code&gt;char&lt;/code&gt; cannot be found.
     *
     * @see String#indexOf(int)
     */
    public static Fn&lt;String, Integer&gt; indexOf(final char c) {
<span class="fc" id="L545">        return when(notNull, new Fn&lt;String, Integer&gt;() {</span>
            @Override public Integer $(String s) {
<span class="fc" id="L547">                int index = s.indexOf(c);</span>
<span class="fc bfc" id="L548" title="All 2 branches covered.">                return index &gt;= 0 ? index : null;</span>
            }});
    }


    /**
     * Yields index position of last occurence of a &lt;code&gt;char&lt;/code&gt;, or &lt;code&gt;null&lt;/code&gt;
     * if the &lt;code&gt;char&lt;/code&gt; cannot be found.
     *
     * @see String#indexOf(int)
     */
<span class="fc" id="L559">    public static Fn&lt;String, Integer&gt; lastIndexOf(final char c) { return when(notNull, new Fn&lt;String, Integer&gt;() {</span>
        @Override public Integer $(String s) {
<span class="fc" id="L561">            int index = s.lastIndexOf(c);</span>
<span class="fc bfc" id="L562" title="All 2 branches covered.">            return index &gt;= 0 ? index : null;</span>
        }});
    }


    /**
     * Yields index position of first occurence of a substring, or &lt;code&gt;null&lt;/code&gt;
     * if the substring cannot be found.
     *
     * @see String#indexOf(String)
     */
    public static Fn&lt;String, Integer&gt; indexOf(final String substring) {
<span class="fc bfc" id="L574" title="All 2 branches covered.">        if (substring == null) return always(null);</span>
<span class="fc" id="L575">        return when(notNull, new Fn&lt;String, Integer&gt;() {</span>
            @Override public Integer $(String s) {
<span class="fc" id="L577">                int index = s.indexOf(substring);</span>
<span class="fc bfc" id="L578" title="All 2 branches covered.">                return index &gt;= 0 ? index : null;</span>
            }});
    }



    /**
     * Yields index position of last occurence of a substring, or &lt;code&gt;null&lt;/code&gt;
     * if the substring cannot be found.
     *
     * @see String#indexOf(String)
     */
    public static Fn&lt;String, Integer&gt; lastIndexOf(final String substring) {
<span class="fc bfc" id="L591" title="All 2 branches covered.">        if (substring == null) return always(null);</span>
<span class="fc" id="L592">        return when(notNull, new Fn&lt;String, Integer&gt;() {</span>
            @Override public Integer $(String s) {
<span class="fc" id="L594">                int index = s.lastIndexOf(substring);</span>
<span class="fc bfc" id="L595" title="All 2 branches covered.">                return index &gt;= 0 ? index : null;</span>
            }});
    }


    /**
     * Split a string on each occurence of a substring.
     * The substring is not included in the resulting strings, and any
     * consecutive substring are treated as one delimiter instance.
     *
     * @param substring
     */
    public static Fn&lt;String, Iterable&lt;String&gt;&gt; splittingOn(final String substring) {
<span class="fc" id="L608">        return new Fn&lt;String, Iterable&lt;String&gt;&gt;() {</span>
            @Override public Iterable&lt;String&gt; $(String string) {
<span class="fc" id="L610">                return new SplitOnSubstring(string, substring);</span>
            }};
    }


    /**
     * Split a string on each occurence of a &lt;code&gt;char&lt;/code&gt; delimiter.
     * The splitting character is not included in the resulting strings, and any
     * consecutive occurrences of the character are treated as one delimiter instance.
     *
     * @param character the delimiter character
     */
<span class="fc" id="L622">    public static Fn&lt;String, Iterable&lt;String&gt;&gt; splittingOn(char character) { return splittingOn(equalTo(character)); }</span>


    /**
     * Split a string into several on any character passing the given
     * &lt;code&gt;Character&lt;/code&gt; predicate.
     * The characters accepted by the predicate is not included in the
     * resulting strings, and any consecutive accepted characters are
     * treated as one delimiter instance.
     *
     * @param character the predicate which decides if a character is
     *                  a delimiter.
     */
    public static Fn&lt;String, Iterable&lt;String&gt;&gt; splittingOn(final Predicate&lt;? super Character&gt; character) {
<span class="fc" id="L636">        return new Fn&lt;String, Iterable&lt;String&gt;&gt;() {</span>
            @Override public Iterable&lt;String&gt; $(String string) {
<span class="fc" id="L638">                return new SplitOnCharacter(string, character);</span>
            }};
    }


<span class="fc" id="L643">    private Strings() {}</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.1.201405082137</span></div></body></html>